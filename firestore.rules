/**
 * Core Philosophy: This ruleset implements a hybrid security model. It enforces a
 * strict user-ownership model for personal data, while treating global, application-wide
 * data as publicly readable but non-writable by clients.
 *
 * Data Structure: User-specific data, such as a user's profile, is nested within a
 * user-specific document tree (/users/{userId}/...). This allows for simple,
 * path-based ownership rules. Global data, such as locations and risk assessments,
 * is stored in top-level collections for easy public access and querying.
 *
 * Key Security Decisions:
 * - User Data Privacy: A user can only access their own data. They cannot read or
 *   write to another user's data tree.
 * - Public Read-Only Data: The `locations`, `riskAssessments`, and `safetyAdvisories`
 *   collections are publicly readable by any client, including unauthenticated ones.
 *   Writes to these collections are disabled for clients, assuming they are managed
 *   by a trusted backend service.
 * - Denormalization for Authorization: The rules rely on the `/users/{userId}` path
 *   to determine ownership, avoiding the need for extra database reads to check
 *   permissions. For user profiles, an internal `id` field must match the `{userId}`
 *   in the path, ensuring relational integrity upon creation.
 * - Structural Segregation: Private user data (`userProfiles`) is stored in a
 *   separate, user-scoped collection, completely segregated from public data. This
 *   is more secure and performant than mixing public and private documents in the
 *   same collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's ID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document currently exists in Firestore.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the user is the owner of an existing document.
     * Crucial for preventing updates or deletes on non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * On create, validates that the new document's internal `id` field
     * matches the owner's UID from the path. This enforces data consistency.
     */
    function isCreatingOwnProfile(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * On update, ensures the internal `id` field of a UserProfile is immutable,
     * preventing the ownership link from being changed.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Secures a user's private profile data. Only the authenticated
     * owner of the profile can read, create, update, or delete it.
     * @path /users/{userId}/userProfiles/{profileId}
     * @allow A user with UID 'user_abc' (create)s their own profile in `/users/user_abc/userProfiles/profile123`.
     * @deny A user with UID 'user_xyz' attempts to (get) a profile from `/users/user_abc/userProfiles/profile123`.
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId}/userProfiles/{profileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnProfile(userId);
      allow update: if isExistingOwner(userId) && isUserIdImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Defines rules for location data. Locations are considered public
     * information, readable by anyone. Writes are disabled for clients, assuming
     * this data is managed by a trusted backend.
     * @path /locations/{locationId}
     * @allow An unauthenticated user (list)s all documents in the `/locations` collection.
     * @deny Any user, authenticated or not, attempts to (create) a new location document.
     * @principle Enables public read access for global data while preventing modification by clients.
     */
    match /locations/{locationId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Defines rules for risk assessment data. This data is public and
     * can be read by any client. Client-side writes are disabled to protect data integrity,
     * assuming a backend service generates these assessments.
     * @path /riskAssessments/{riskAssessmentId}
     * @allow Any user (get)s a specific risk assessment document.
     * @deny An authenticated user attempts to (update) a risk assessment.
     * @principle Enables public read access for global data while preventing modification by clients.
     */
    match /riskAssessments/{riskAssessmentId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Defines rules for AI-generated safety advisories. These advisories are
     * public and readable by all users. To ensure authenticity and integrity, client-side
     * writes are prohibited.
     * @path /safetyAdvisories/{safetyAdvisoryId}
     * @allow An authenticated user (list)s all safety advisories.
     * @deny Any user attempts to (delete) a safety advisory.
     * @principle Enables public read access for global data while preventing modification by clients.
     */
    match /safetyAdvisories/{safetyAdvisoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}